<!-- <!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - exporter - gltf</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			webgl - exporter - gltf
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
			// import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
			// import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
			import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
			import { GUI } from "three/addons/libs/lil-gui.module.min.js";
			import * as TextureUtils from "three/addons/utils/WebGLTextureUtils.js";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import TWEEN from "three/addons/tween/tween.esm.js";

			// Scene
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x111111);

			// Camera
			const camera = new THREE.PerspectiveCamera(
				75,
				window.innerWidth / window.innerHeight,
				1,
				500
			);
			camera.position.set(60, 60, 60); // ƒë·∫∑t xa ƒë·ªÉ nh√¨n to√†n c·∫£nh
			// camera.lookAt(0, 0, 0);

			// Renderer
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			// OrbitControls
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.5;

			// === M·∫∂T S√ÄN ===
			const floorGeometry = new THREE.PlaneGeometry(50, 150);
			const floorMaterial = new THREE.MeshBasicMaterial({
				color: 0x333323,
				side: THREE.DoubleSide,
			});
			const floor = new THREE.Mesh(floorGeometry, floorMaterial);
			floor.rotation.x = -Math.PI / 2; // xoay n·∫±m ngang
			scene.add(floor);

			// // === L∆Ø·ªöI M√ÄU XANH L√Å ===
			// const gridHelper = new THREE.GridHelper(100, 100, 0x00ff00, 0x00ff00);
			// gridHelper.scale.x = 0.5; // ƒë·ªÉ chi·ªÅu r·ªông c√≤n 50m
			// scene.add(gridHelper);

			// === L∆Ø·ªöI XANH L√Å 1m x 1m ===
			function createCustomGrid(width, height, color) {
				const gridMaterial = new THREE.LineBasicMaterial({ color: color });
				const gridGeometry = new THREE.BufferGeometry();
				const vertices = [];

				// k·∫ª ƒë∆∞·ªùng song song tr·ª•c X (chia theo chi·ªÅu d√†i)
				for (let i = 0; i <= height; i++) {
					const z = -height / 2 + i;
					vertices.push(-width / 2, 0.01, z, width / 2, 0.01, z);
				}

				// k·∫ª ƒë∆∞·ªùng song song tr·ª•c Z (chia theo chi·ªÅu r·ªông)
				for (let i = 0; i <= width; i++) {
					const x = -width / 2 + i;
					vertices.push(x, 0.01, -height / 2, x, 0.01, height / 2);
				}

				gridGeometry.setAttribute(
					"position",
					new THREE.Float32BufferAttribute(vertices, 3)
				);
				return new THREE.LineSegments(gridGeometry, gridMaterial);
			}

			const customGrid = createCustomGrid(20, 20, 0x00ff00);
			scene.add(customGrid);

			// light
			const light = new THREE.DirectionalLight(0xffffff, 1.0);
			light.position.set(50, 100, 50);
			scene.add(light);
			scene.add(new THREE.AmbientLight(0x404040, 0.6));

			// ----- M·ªôt v·∫≠t th·ªÉ (h·ªôp) -----
            const h = 1; //Chi·ªÅu cao h·ªôp
			const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
			const boxMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
			const box = new THREE.Mesh(boxGeometry, boxMaterial);
			box.position.set(5, h/2, 5); // ƒë·∫∑t t√πy √Ω tr√™n plane
			scene.add(box);

			// // === Tr·ª•c t·ªça ƒë·ªô ===
			// const axesHelper = new THREE.AxesHelper(10);
			// scene.add(axesHelper);

			// H√¨nh c·∫ßu
			const radius = 1;
			const geometry = new THREE.SphereGeometry(radius, 32, 32);
			const material = new THREE.MeshStandardMaterial({ color: 0x0077ff });
			const sphere = new THREE.Mesh(geometry, material);
			// ƒê·∫∑t sphere cao l√™n = b√°n k√≠nh ƒë·ªÉ n√≥ n·∫±m tr√™n m·∫∑t ph·∫≥ng
			sphere.position.y = radius;
			scene.add(sphere);

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			function onMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}
			window.addEventListener("mousemove", onMouseMove, false);

			function onMouseWheel(event) {
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects([sphere]); // ho·∫∑c scene.children

				if (intersects.length > 0) {
					const point = intersects[0].point; // ƒëi·ªÉm tr√™n sphere d∆∞·ªõi chu·ªôt
					const dir = new THREE.Vector3().subVectors(point, camera.position);
					const factor = event.deltaY < 0 ? 0.1 : -0.1;

					// D·ªãch camera v√† target theo c√πng m·ªôt vector => zoom th·∫≥ng
					const move = dir.normalize().multiplyScalar(factor * dir.length());
					camera.position.add(move);
					controls.target.add(move); // d·ªãch lu√¥n target
				}
			}
			window.addEventListener("wheel", onMouseWheel, { passive: true });

			// X·ª≠ l√Ω resize
			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Loop
			function animate() {
				requestAnimationFrame(animate);

				// tween.update();
				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html> -->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - collada - skinning</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="container"></div>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			collada loader - skinning<br />
			Dancing Stormtrooper by
			<a
				href="https://sketchfab.com/strykerdoesgames"
				target="_blank"
				rel="noopener"
				>StrykerDoesAnimation</a
			>,
			<a
				href="https://creativecommons.org/licenses/by/4.0/"
				target="_blank"
				rel="noopener"
				>CC Attribution</a
			>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import Stats from "three/addons/libs/stats.module.js";

			import { ColladaLoader } from "three/addons/loaders/ColladaLoader.js";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
			import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";

			let container, stats, clock, controls;
			let camera, scene, renderer, mixer, mouse, raycaster;

			init();

			function init() {
				container = document.getElementById("container");

				camera = new THREE.PerspectiveCamera(
					50,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.set(0, 20, -20);

				scene = new THREE.Scene();

				clock = new THREE.Clock();
				// Khai b√°o bi·∫øn to√†n c·ª•c
				mouse = new THREE.Vector2();
				raycaster = new THREE.Raycaster();

				// collada

				const loader = new ColladaLoader();
				loader.load(
					"./models/collada/stormtrooper/stormtrooper.dae",
					function (collada) {
						const avatar = collada.scene;
						const animations = avatar.animations;

						mixer = new THREE.AnimationMixer(avatar);
						mixer.clipAction(animations[0]).play();

						scene.add(avatar);
					}
				);

				//

				// const gridHelper = new THREE.GridHelper(10, 20, 0x008000, 0xff00000);
				// scene.add(gridHelper);

				//

				const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
				scene.add(ambientLight);

				const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
				directionalLight.position.set(1.5, 1, -1.5);
				scene.add(directionalLight);

				//

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop(animate);
				container.appendChild(renderer.domElement);

				//

				controls = new OrbitControls(camera, renderer.domElement);
				controls.screenSpacePanning = true;
				controls.minDistance = 5;
				controls.maxDistance = 100;
				// controls.target.set( 0, 2, 0 );
				controls.update();

				//

				stats = new Stats();
				container.appendChild(stats.dom);

				//

				window.addEventListener("resize", onWindowResize);

				// üî• Zoom theo con tr·ªè
				renderer.domElement.addEventListener("wheel", onMouseWheel, {
					passive: false,
				});

				const customGrid = createCustomGrid(50, 80, 0x00ff00);
				scene.add(customGrid);

				// === M·∫∂T S√ÄN ===
				const textureLoader = new THREE.TextureLoader();
				const floorTexture = textureLoader.load("textures/rock.jpg");

				const floorGeometry = new THREE.PlaneGeometry(50, 80);
				const floorMaterial = new THREE.MeshBasicMaterial({
					// color: 0x333323,
					// side: THREE.DoubleSide,
					map: floorTexture,
				});
				const floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.position.y = 0;
				floor.rotation.x = -Math.PI / 2; // xoay n·∫±m ngang
				floor.receiveShadow = true;
				scene.add(floor);

				// const loader1 = new GLTFLoader();
				// loader.load("jsm/rock.glb", (gltf) => {
				// 	gltf.scene.traverse((child) => {
				// 		if (child.isMesh) {
				// 			const mat = child.material; // l·∫•y material trong GLB

				// 			// t·∫°o s√†n t·ª´ plane v√† g√°n material n√†y
				// 			const geometry = new THREE.PlaneGeometry(10, 10, 10, 10);
				// 			const mesh = new THREE.Mesh(geometry, mat);
				// 			mesh.rotation.x = -Math.PI / 2;
				// 			scene.add(mesh);
				// 		}
				// 	});
				// });

				// T·∫°o AxesHelper v·ªõi chi·ªÅu d√†i c·ªßa c√°c tr·ª•c l√† 5
				const axesHelper = new THREE.AxesHelper(5);
				scene.add(axesHelper);
			}

			// === L∆Ø·ªöI XANH L√Å 1m x 1m ===
			function createCustomGrid(width, height, color) {
				const gridMaterial = new THREE.LineBasicMaterial({ color: color });
				const gridGeometry = new THREE.BufferGeometry();
				const vertices = [];

				// k·∫ª ƒë∆∞·ªùng song song tr·ª•c X (chia theo chi·ªÅu d√†i)
				for (let i = 0; i <= height; i++) {
					const z = -height / 2 + i;
					vertices.push(-width / 2, 0.01, z, width / 2, 0.01, z);
				}

				// k·∫ª ƒë∆∞·ªùng song song tr·ª•c Z (chia theo chi·ªÅu r·ªông)
				for (let i = 0; i <= width; i++) {
					const x = -width / 2 + i;
					vertices.push(x, 0.01, -height / 2, x, 0.01, height / 2);
				}

				gridGeometry.setAttribute(
					"position",
					new THREE.Float32BufferAttribute(vertices, 3)
				);
				return new THREE.LineSegments(gridGeometry, gridMaterial);
			}

			function onMouseWheel(event) {
				event.preventDefault();

				// V·ªã tr√≠ chu·ªôt chu·∫©n h√≥a (-1,1)
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

				// B·∫Øn ray t·ª´ camera
				raycaster.setFromCamera(mouse, camera);

				const targetPoint = new THREE.Vector3();
				raycaster.ray.intersectPlane(plane, targetPoint);

				if (targetPoint) {
					// vector t·ª´ camera t·ªõi targetPoint
					const dir = new THREE.Vector3().subVectors(
						targetPoint,
						camera.position
					);

					// t·ª∑ l·ªá zoom (deltaY > 0 = zoom out, < 0 = zoom in)
					const scale = event.deltaY > 0 ? 1.1 : 0.9;

					// di chuy·ªÉn c·∫£ camera v√† target
					camera.position.addScaledVector(dir, 1 - scale);
					controls.target.addScaledVector(dir, 1 - scale);

					controls.update();
				}
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				render();
				stats.update();
			}

			function render() {
				const delta = clock.getDelta();

				if (mixer !== undefined) {
					mixer.update(delta);
				}

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
